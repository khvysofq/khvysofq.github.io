---
layout: post
title: 网络通信协议设计与实现分析
---
协议是什么，简单来说：**协议是两个实体之间正确交流信息的规则**。而**实体**这个词语的含义非常广泛，它可以是我们传统意义上的网络通信节点，网络应用程序，还可以是两个进程，甚至还可以是两个线程。只要两个可以划分的独立体需要出现信息，那么它们之间都存在着协议。唯一的差别就是协议的传输方式和复杂度。只要有交流，就会有协议！

![协议嵌套](/img/proto/network_base.png)

<!--more-->

- 按照优先级排序，协议设计的时候应该从**正确性** > **实现简单** > **安全** > **效率** > **扩展性高**这几个方面进行考虑。
- 所有的协议在设计的时候重点考虑实现上的简单，或者给出一系列实现上的指导意见。

正确性是最重要的前提条件，正确性主要指的是在至少在理论上满足需求，并没有明显的缺陷。其次是实现简单，这是最重要的一条，所有的协议要使用起来都必须经过实现这一个步骤，协议设计起来看起来很好，但是实现上用起是非常麻烦，那么这个设计的这协议显然是非常失败的，这也是最常见的一种典型性失败。设计一个能够简单实现的协议看起来并不是一个十分困难的事情，但是如果兼顾安全、效率和扩展性的话，那么设计出一个简单实现的协议就变得非常难了。所以协议设计的精髓可以归为一句话。

> 设计一种正确，实现简单但是安全、高效并且扩展性高的通信方式。

##前提条件
本文的主要目标是针对网络应用中的协议进行比较深入详细的分析，并且总结出一套可以使用的协议设计原理。既然是网络协议那么就有几个非常重要的前提条件。

本文所讨论的通信协议主要是基于可靠传输的网络协议，也就是说在一般的网络中主要以TCP为载体的可靠传输网络。而基于UDP的网络协议暂时不考虑，因为使用不可靠传输网络需要考虑的问题非常多，包丢失、包乱序、网络拥塞等等，这将会把一个原本比较简单的问题极大的复杂化。为了突出重点，所以默认情况下，本文下方的传输协议就运行在TCP以及类似的可靠传输网络上面，如果有例外会进行额外标注。

以TCP为**载体**，这个**载体**是协议设计里面的一个重要概念。TCP本身是一种协议，它主要解决了在不可靠传输网络中最优化传输可靠数据问题，而在TCP之下有IP层，在IP层之下有数据链路层。每一层都解决了某一个特定问题，每一层都是不同的协议，而这种协议是层级嵌套的。A协议被B协议封装、B协议也被C协议封装，最后C协议通过网络库传输到对端。这种特征类似于数据结构**栈**，所以我们常常称一组嵌套的协议为**协议栈**。

![协议嵌套](/img/proto/network_layer.png)

上图就是大家所常见的协议嵌套的一般模型，以常见的HTTP为例，HTTP协议包头可以看成是A，而HTTP包头里面携带的数据是B，而以下就是操作系统提供的网络协议栈了。

安全是一个大问题，这是协议在设计的时候考虑的重点。但是并不能够盲目的考虑，在讨论安全的时候我们需要建立在一定的基础之上才有实际的意义。我们这个文档所讨论的协议是应用层协议，所以会建立在操作系统所提供的栈之上。

- 如果是基于TCP栈的协议，简单的SYN洪水攻击可以非常容易把一台普通服务器拖死。
- 如果是基于UDP栈的协议，那么同样的DDOS攻击也可以把这个端口给堵死了。

这是操作系统栈的问题，显然并不是应用层协议能够解决的问题。所以我们讨论的安全主要集中在以下几个方面

1. 如果接收到的数据是错误的格式，那么应该怎么处理？
2. 协议格式是正确的，但是所请求的对象、资源或者方法并不存在应该怎样处理？
3. 如果客户端访问太过频繁，明显超过协议设计时的预期应该怎么办？
4. 如果是基于TCP协议栈，但是客户端与服务端建立了过多的连接，但是并不发送数据，将服务器资源占用完了，怎么办？

##从简单开始
所有的通信协议都是为了交互有用的信息，而有用的信息在软件中就是需求，所以接下来我们从需求开始从一个简单的协议一步一步的扩展到一系列复杂的需求中去。
###一个简单的延迟测试服务

####需求描述
> 有一个客户端一个服务器，客户端能够有办法测试出数据从客户端发送到服务器，再从服务器返回到客户端这个过程中的**网络**和**服务器处理速度**的**相对延迟**情况，精确到毫秒级。

####解决方案分析
这是一个再简单不过的需求，我们很容易想到一种简单的解决方案：客户端使用一个32bits(4bytes)长度的数据保存本机自启动到当前的毫秒时间，然后发送给服务器，服务器再原封不动的返回这个数据。客户端接收到回复之后计算前后时间差，就可以得出网络和服务器处理的延迟情况。多请求几次就可以得到相对的延迟情况，这个动态的数据就变得十分有意义了。

对于服务端来说，这是一个典型的ECHO Server，服务端只需要把自己所收到的任务数据原封不动的返回就可以了，立即返回。而客户端每一次发送一个4bytes的数据，每一次接收4bytes的数据，功能非常清晰，实现也非常简单。

前面已经说过，我们本文所讨论的所有协议不做特别说明默认都运行在TCP之上。因为UDP由于其乱序和丢失的情况会将问题复杂化，不利于讨论问题的核心。不过对于上面这个简单的需求，我们还是完全可以考虑使用UDP的，甚至针对这个需求来说UDP比TCP更加合理方便。不管是用TCP还是UDP，我们所设计的简单协议已经满足了上面的需求了。不过还需要做一些实现和验证性分析。
从实现上来看，如果使用UDP协议，那么每一次都往服务器发送一个固定大小的包，等待返回并且计算就已经可以了。由于是无连接的，所以服务器能够处理非常多的请求，效率非常高。而UDP协议里面的包乱序和包丢失现象都不会影响到需求。只要收到服务器回复的任何数据都能够计算延时，甚至更加准确。
而对于使用TCP实现来说，我们可以每一次都与服务器建立一个连接请求，然后发送回复一个数据包，再关闭连接。这样的短连接测试出来的延时是多次交互之后的延迟时间，可能比较长，这样每一次都建立一个新的连接也比较浪费服务器的资源，所以可以考虑建立一个TCP的长连接，这样建立一次连接与服务器进行多次交互，效率更高。由于都是传输的数据类型和长度是固定的，所以不会遇到TCP的粘包问题。

- **正确性**：从理论上面来分析，这种简单的协议只会发送一固定类型、固定大小的数据，是正确的，也能够完全满足需求。
- **实现简单**：客户端和服务端进行的数据交互类型只有一种，不管使用TCP还是UDP流程都非常简单，所以实现上也非常简单。
- **效率**：UDP的效率最高，而使用TCP长连接的效率比使用TCP短连接的效率高一些。
- **安全**：这种协议安全吗？如果一个恶意的客户端只发送低于4bytes的数据，服务器端是否有问题？如果客户端一次向服务器发送大量数据，服务器端应该怎么处理？如果有几万个客户端只建立TCP连接，而不向服务器发送数据应该怎么办？我们还有一些问题没有讨论。

如果不讨论这些问题，从理论上来说协议上是没有问题的，但是当一个实现者拿到这个协议的时候总会遇到这些问题，然后就会按照自己的情况进行不同的实现，这就造成了不同的实现有可能不兼容的现象。

>FTP协议中关于当前目录列表的格式就没有进行明确的定义，这就造成了不同的FTP实现有不同的文件格式。当前世面上的FTP服务器，运行在Windows平台下的FTP服务器有自己目录格式，运行在Linux系统下的FTP服务器有自己的目录格式，有一些软件还有自己定义的目录格式。
>当我们在实现FTP客户端的时候就会发现，里面最麻烦的问题就是解析目录格式，在RFC 959的FTP协议定义里面对文件的目录有这样的描述：

>>Since the information on a file may vary widely from system to system, this information may be hard to use automatically in a program, but may be quite useful to a human user.

如果客户端发送过多数据，或者过少数据。正常情况下协议定义的是四个字节为一组，如果服务器在实现时每一次需要读取到四个字节的数据之后再返回给客户端的话，在发送过少数据的情况下，服务器端势必会等待数据，对服务器端来说必然不是一件好事。同样数据过多，服务器每一次处理4个字节，也太过繁忙了。所以在实现的时候**应该**将服务器实现为标准的Echo Server，服务器端每一次**应该**不管数据长度，尽量读取数据，然后直接返回。当数据返回完之后，再处理后面的数据。这样就可以有效的避免客户端恶意发送数据的情况。

同时我们还**建议**，客户端应该有一个超时时间，如果发送请求之后，在一定时间内没有收到服务器的回复则超时，超时时间**建议**设置为4s（与ICMP的超时时间一样）。

这样安全吗？还不够安全？甚至不够正确！我们没有对客户端与服务端之间交互的频率做规定。虽然应该将服务器实现为标准的Echo Server，但是考虑到我们的需求，如果客户端太过平凡发送请求或者一次发送过多请求都不能够更好的测试出“网络和服务器处理速度的相对延迟”情况。所以我们建议客户端**应该**每一次只发送一个请求，收到上一次的请求或者超时之后，再发送下一个请求，**不应该**一次性发送两个请求。同时**建议**客户端在接收到回复至少1s之后，再发送下一个请求。

如果实现的时候使用的是TCP长连接，那么这个时候就必须要考虑NAT和防火墙对连接的影响，因为在默认的情况下NAT和防火墙会主动取消在“老化时间（Aging Time）”没有数据传输的TCP连接的映射关系，导致双方连接异常。所以如果是使用TCP长连接的形式实现，客户端**必须**在一个合理的时间内向服务器发送一次数据，**建议**时间为6分钟。如果服务器端检测客户端在一定时间内都没有数据，**应该**将客户端的连接断开。

看到上面的**必须**、**应该**、**不应该**、**建议**这样的字眼没。这些都是在RFC文档里面经常出现的字眼。都是在实现上面的中肯提议。

####小结
通过上面的分析，我们已经对这个协议的方方面面进行了讨论，现在我们已经有了一个完全可以使用，在正确性、易用性、效率和安全上面都有一定保障的协议。

以下未完成！
---

针对TCP协议来说，



- 是否支持代理（命名规则）
- 是否支持路由（TO、FROM、路由表、MAX_FORWARD）
- 是否支持推送消息（长连接、登录、登出、心跳包）
- 是否支持通道复用（双层Message ID号）
- 传输和应用层独立(命名)
- 跨外网
- 是否区分消息达到对象
- 有消息长度就在注意长度溢出问题。
- 撤消功能（撤消前一个任务）

##应用

当前所了解的协议

- RTSP、RTP
- XMPP
- HTTP
- XMPP
- SIP
- FTP

##需求变更模型
- ECHO Server(直接回复所有的收到的数据)


---